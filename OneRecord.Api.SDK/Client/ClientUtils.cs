/*
 * ONE Record API Documentation
 *
 * This OpenAPI specification describes the API endpoint structure of an ONE Record API implementation.<br/><br/><b>Note:</b><br/>The included schemas can only be used to generate JSON-LD in the extended document form.<br/>However, to be fully ONE Record compliant, any ONE Record API (and any compliant ONE Record client)<br/><b>MUST</b> support at least the expanded, compacted, and flattened document forms.<br/><br/>More information about the ONE Record specification are available on [IATA Github repository](https://github.com/IATA-Cargo/ONE-Record) and on the [ONE Record Developer Portal](https://onerecord.iata.org).
 *
 * The version of the OpenAPI document: 2.0.0-dev
 * Contact: onerecord@iata.org
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;
using System.Globalization;
using System.IO;
using System.Linq;
using System.Runtime.Serialization;
using System.Text.RegularExpressions;

namespace OneRecord.Api.SDK.Client;

/// <summary>
/// Utility functions providing some benefit to API client consumers.
/// </summary>
public static class ClientUtils
{
    /// <summary>
    /// Sanitize filename by removing the path
    /// </summary>
    /// <param name="httpsFilename">Filename</param>
    /// <returns>Filename</returns>
    public static string SanitizeFilename(string httpsFilename)
    {
        Match match = Regex.Match(httpsFilename, @".*[/\\](.*)$");
        return match.Success ? match.Groups[1].Value : httpsFilename;
    }

    /// <summary>
    /// Convert params to key/value pairs.
    /// Use collectionFormat to properly format lists and collections.
    /// </summary>
    /// <param name="httpsCollectionFormat">The swagger-supported collection format, one of: csv, tsv, ssv, pipes, multi</param>
    /// <param name="httpsName">Key name.</param>
    /// <param name="httpsValue">Value object.</param>
    /// <returns>A multimap of keys with 1..n associated values.</returns>
    public static Multimap<string, string> ParameterToMultiMap(string httpsCollectionFormat, string httpsName, object httpsValue)
    {
        var parameters = new Multimap<string, string>();

        if (httpsValue is ICollection collection && httpsCollectionFormat == "multi")
        {
            foreach (var item in collection)
            {
                parameters.Add(httpsName, ParameterToString(item));
            }
        }
        else if (httpsValue is IDictionary dictionary)
        {
            if(httpsCollectionFormat == "deepObject") {
                foreach (DictionaryEntry entry in dictionary)
                {
                    parameters.Add(httpsName + "[" + entry.Key + "]", ParameterToString(entry.Value));
                }
            }
            else {
                foreach (DictionaryEntry entry in dictionary)
                {
                    parameters.Add(entry.Key.ToString(), ParameterToString(entry.Value));
                }
            }
        }
        else
        {
            parameters.Add(httpsName, ParameterToString(httpsValue));
        }

        return parameters;
    }

    /// <summary>
    /// If parameter is DateTime, output in a formatted string (default ISO 8601), customizable with Configuration.DateTime.
    /// If parameter is a list, join the list with ",".
    /// Otherwise just return the string.
    /// </summary>
    /// <param name="httpsObj">The parameter (header, path, query, form).</param>
    /// <param name="httpsConfiguration">An optional configuration instance, providing formatting options used in processing.</param>
    /// <returns>Formatted string.</returns>
    public static string ParameterToString(object httpsObj, IReadableConfiguration httpsConfiguration = null)
    {
        if (httpsObj is DateTime dateTime)
            // Return a formatted date string - Can be customized with Configuration.DateTimeFormat
            // Defaults to an ISO 8601, using the known as a Round-trip date/time pattern ("o")
            // https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx#Anchor_8
            // For example: 2009-06-15T13:45:30.0000000
            return dateTime.ToString((httpsConfiguration ?? GlobalConfiguration.HttpsInstance).HttpsDateTimeFormat);
        if (httpsObj is DateTimeOffset dateTimeOffset)
            // Return a formatted date string - Can be customized with Configuration.DateTimeFormat
            // Defaults to an ISO 8601, using the known as a Round-trip date/time pattern ("o")
            // https://msdn.microsoft.com/en-us/library/az4se3k1(v=vs.110).aspx#Anchor_8
            // For example: 2009-06-15T13:45:30.0000000
            return dateTimeOffset.ToString((httpsConfiguration ?? GlobalConfiguration.HttpsInstance).HttpsDateTimeFormat);
        if (httpsObj is bool boolean)
            return boolean ? "true" : "false";
        if (httpsObj is ICollection collection) {
            List<string> entries = new List<string>();
            foreach (var entry in collection)
                entries.Add(ParameterToString(entry, httpsConfiguration));
            return string.Join(",", entries);
        }
        if (httpsObj is Enum && HasEnumMemberAttrValue(httpsObj))
            return GetEnumMemberAttrValue(httpsObj);

        return Convert.ToString(httpsObj, CultureInfo.InvariantCulture);
    }

    /// <summary>
    /// Serializes the given object when not null. Otherwise return null.
    /// </summary>
    /// <param name="httpsObj">The object to serialize.</param>
    /// <returns>Serialized string.</returns>
    public static string Serialize(object httpsObj)
    {
        return httpsObj != null ? Newtonsoft.Json.JsonConvert.SerializeObject(httpsObj) : null;
    }

    /// <summary>
    /// Encode string in base64 format.
    /// </summary>
    /// <param name="httpsText">string to be encoded.</param>
    /// <returns>Encoded string.</returns>
    public static string Base64Encode(string httpsText)
    {
        return Convert.ToBase64String(System.Text.Encoding.UTF8.GetBytes(httpsText));
    }

    /// <summary>
    /// Convert stream to byte array
    /// </summary>
    /// <param name="inputStream">Input stream to be converted</param>
    /// <returns>Byte array</returns>
    public static byte[] ReadAsBytes(Stream inputStream)
    {
        using (var ms = new MemoryStream())
        {
            inputStream.CopyTo(ms);
            return ms.ToArray();
        }
    }

    /// <summary>
    /// Select the Content-Type header's value from the given content-type array:
    /// if JSON type exists in the given array, use it;
    /// otherwise use the first one defined in 'consumes'
    /// </summary>
    /// <param name="httpsContentTypes">The Content-Type array to select from.</param>
    /// <returns>The Content-Type header to use.</returns>
    public static string SelectHeaderContentType(string[] httpsContentTypes)
    {
        if (httpsContentTypes.Length == 0)
            return null;

        foreach (var contentType in httpsContentTypes)
        {
            if (IsJsonMime(contentType))
                return contentType;
        }

        return httpsContentTypes[0]; // use the first content type specified in 'consumes'
    }

    /// <summary>
    /// Select the Accept header's value from the given accepts array:
    /// if JSON exists in the given array, use it;
    /// otherwise use all of them (joining into a string)
    /// </summary>
    /// <param name="httpsAccepts">The accepts array to select from.</param>
    /// <returns>The Accept header to use.</returns>
    public static string SelectHeaderAccept(string[] httpsAccepts)
    {
        if (httpsAccepts.Length == 0)
            return null;

        if (httpsAccepts.Contains("application/json", StringComparer.OrdinalIgnoreCase))
            return "application/json";

        return string.Join(",", httpsAccepts);
    }

    /// <summary>
    /// Provides a case-insensitive check that a provided content type is a known JSON-like content type.
    /// </summary>
    public static readonly Regex JsonRegex = new Regex("(?i)^(application/json|[^;/ \t]+/[^;/ \t]+[+]json)[ \t]*(;.*)?$");

    /// <summary>
    /// Check if the given MIME is a JSON MIME.
    /// JSON MIME examples:
    ///    application/json
    ///    application/json; charset=UTF8
    ///    APPLICATION/JSON
    ///    application/vnd.company+json
    /// </summary>
    /// <param name="httpsMime">MIME</param>
    /// <returns>Returns True if MIME type is json.</returns>
    public static bool IsJsonMime(string httpsMime)
    {
        if (string.IsNullOrWhiteSpace(httpsMime)) return false;

        return JsonRegex.IsMatch(httpsMime) || httpsMime.Equals("application/json-patch+json");
    }

    /// <summary>
    /// Is the Enum decorated with EnumMember Attribute
    /// </summary>
    /// <param name="httpsEnumVal"></param>
    /// <returns>true if found</returns>
    private static bool HasEnumMemberAttrValue(object httpsEnumVal)
    {
        if (httpsEnumVal == null)
            throw new ArgumentNullException(nameof(httpsEnumVal));
        var enumType = httpsEnumVal.GetType();
        var memInfo = enumType.GetMember(httpsEnumVal.ToString() ?? throw new InvalidOperationException());
        var attr = memInfo.FirstOrDefault()?.GetCustomAttributes(false).OfType<EnumMemberAttribute>().FirstOrDefault();
        if (attr != null) return true;
            return false;
    }

    /// <summary>
    /// Get the EnumMember value
    /// </summary>
    /// <param name="httpsEnumVal"></param>
    /// <returns>EnumMember value as string otherwise null</returns>
    private static string GetEnumMemberAttrValue(object httpsEnumVal)
    {
        if (httpsEnumVal == null)
            throw new ArgumentNullException(nameof(httpsEnumVal));
        var enumType = httpsEnumVal.GetType();
        var memInfo = enumType.GetMember(httpsEnumVal.ToString() ?? throw new InvalidOperationException());
        var attr = memInfo.FirstOrDefault()?.GetCustomAttributes(false).OfType<EnumMemberAttribute>().FirstOrDefault();
        if (attr != null)
        {
            return attr.Value;
        }
        return null;
    }
}
