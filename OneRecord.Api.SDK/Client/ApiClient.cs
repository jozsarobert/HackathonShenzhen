/*
 * ONE Record API Documentation
 *
 * This OpenAPI specification describes the API endpoint structure of an ONE Record API implementation.<br/><br/><b>Note:</b><br/>The included schemas can only be used to generate JSON-LD in the extended document form.<br/>However, to be fully ONE Record compliant, any ONE Record API (and any compliant ONE Record client)<br/><b>MUST</b> support at least the expanded, compacted, and flattened document forms.<br/><br/>More information about the ONE Record specification are available on [IATA Github repository](https://github.com/IATA-Cargo/ONE-Record) and on the [ONE Record Developer Portal](https://onerecord.iata.org).
 *
 * The version of the OpenAPI document: 2.0.0-dev
 * Contact: onerecord@iata.org
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections.Generic;
using System.IO;
using System.Linq;
using System.Net;
using System.Text.RegularExpressions;
using System.Threading.Tasks;
using Newtonsoft.Json;
using Newtonsoft.Json.Serialization;
using OneRecord.Api.SDK.Model;
using Polly;
using RestSharp;
using RestSharp.Serializers;
using RestSharpMethod = RestSharp.Method;

namespace OneRecord.Api.SDK.Client;

/// <summary>
/// Allows RestSharp to Serialize/Deserialize JSON using our custom logic, but only when ContentType is JSON.
/// </summary>
internal class CustomJsonCodec : IRestSerializer, ISerializer, IDeserializer
{
    private readonly IReadableConfiguration _configuration;
    private readonly JsonSerializerSettings _serializerSettings = new JsonSerializerSettings
    {
        // OpenAPI generated types generally hide default constructors.
        ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor,
        ContractResolver = new DefaultContractResolver
        {
            NamingStrategy = new CamelCaseNamingStrategy
            {
                OverrideSpecifiedNames = false
            }
        }
    };

    public CustomJsonCodec(IReadableConfiguration httpsConfiguration)
    {
        _configuration = httpsConfiguration;
    }

    public CustomJsonCodec(JsonSerializerSettings httpsSerializerSettings, IReadableConfiguration httpsConfiguration)
    {
        _serializerSettings = httpsSerializerSettings;
        _configuration = httpsConfiguration;
    }

    /// <summary>
    /// Serialize the object into a JSON string.
    /// </summary>
    /// <param name="httpsObj">Object to be serialized.</param>
    /// <returns>A JSON string.</returns>
    public string Serialize(object httpsObj)
    {
        if (httpsObj != null && httpsObj is AbstractOpenApiSchema)
        {
            // the object to be serialized is an oneOf/anyOf schema
            return ((AbstractOpenApiSchema)httpsObj).ToJson();
        }
        else
        {
            return JsonConvert.SerializeObject(httpsObj, _serializerSettings);
        }
    }

    public string Serialize(Parameter httpsBodyParameter) => Serialize(httpsBodyParameter.Value);

    public T Deserialize<T>(RestResponse httpsResponse)
    {
        var result = (T)Deserialize(httpsResponse, typeof(T));
        return result;
    }

    /// <summary>
    /// Deserialize the JSON string into a proper object.
    /// </summary>
    /// <param name="httpsResponse">The HTTP response.</param>
    /// <param name="httpsType">Object type.</param>
    /// <returns>Object representation of the JSON string.</returns>
    internal object Deserialize(RestResponse httpsResponse, Type httpsType)
    {
        if (httpsType == typeof(byte[])) // return byte array
        {
            return httpsResponse.RawBytes;
        }

        // TODO: ? if (type.IsAssignableFrom(typeof(Stream)))
        if (httpsType == typeof(Stream))
        {
            var bytes = httpsResponse.RawBytes;
            if (httpsResponse.Headers != null)
            {
                var filePath = string.IsNullOrEmpty(_configuration.HttpsTempFolderPath)
                    ? Path.GetTempPath()
                    : _configuration.HttpsTempFolderPath;
                var regex = new Regex(@"Content-Disposition=.*filename=['""]?([^'""\s]+)['""]?$");
                foreach (var header in httpsResponse.Headers)
                {
                    var match = regex.Match(header.ToString());
                    if (match.Success)
                    {
                        string fileName = filePath + ClientUtils.SanitizeFilename(match.Groups[1].Value.Replace("\"", "").Replace("'", ""));
                        File.WriteAllBytes(fileName, bytes);
                        return new FileStream(fileName, FileMode.Open);
                    }
                }
            }
            var stream = new MemoryStream(bytes);
            return stream;
        }

        if (httpsType.Name.StartsWith("System.Nullable`1[[System.DateTime")) // return a datetime object
        {
            return DateTime.Parse(httpsResponse.Content, null, System.Globalization.DateTimeStyles.RoundtripKind);
        }

        if (httpsType == typeof(string) || httpsType.Name.StartsWith("System.Nullable")) // return primitive type
        {
            return Convert.ChangeType(httpsResponse.Content, httpsType);
        }

        // at this point, it must be a model (json)
        try
        {
            return JsonConvert.DeserializeObject(httpsResponse.Content, httpsType, _serializerSettings);
        }
        catch (Exception e)
        {
            throw new ApiException(500, e.Message);
        }
    }

    public ISerializer Serializer => this;
    public IDeserializer Deserializer => this;

    public string[] AcceptedContentTypes => RestSharp.ContentType.JsonAccept;

    public SupportsContentType SupportsContentType => httpsContentType =>
        httpsContentType.Value.EndsWith("json", StringComparison.InvariantCultureIgnoreCase) ||
        httpsContentType.Value.EndsWith("javascript", StringComparison.InvariantCultureIgnoreCase);

    public ContentType ContentType { get; set; } = RestSharp.ContentType.Json;

    public DataFormat DataFormat => DataFormat.Json;
}
/// <summary>
/// Provides a default implementation of an Api client (both synchronous and asynchronous implementations),
/// encapsulating general REST accessor use cases.
/// </summary>
public partial class ApiClient : ISynchronousClient, IAsynchronousClient
{
    private readonly string _baseUrl;

    /// <summary>
    /// Specifies the settings on a <see cref="JsonSerializer" /> object.
    /// These settings can be adjusted to accommodate custom serialization rules.
    /// </summary>
    public JsonSerializerSettings HttpsSerializerSettings { get; set; } = new JsonSerializerSettings
    {
        // OpenAPI generated types generally hide default constructors.
        ConstructorHandling = ConstructorHandling.AllowNonPublicDefaultConstructor,
        ContractResolver = new DefaultContractResolver
        {
            NamingStrategy = new CamelCaseNamingStrategy
            {
                OverrideSpecifiedNames = false
            }
        }
    };

    /// <summary>
    /// Allows for extending request processing for <see cref="ApiClient"/> generated code.
    /// </summary>
    /// <param name="httpsRequest">The RestSharp request object</param>
    partial void InterceptRequest(RestRequest httpsRequest);

    /// <summary>
    /// Allows for extending response processing for <see cref="ApiClient"/> generated code.
    /// </summary>
    /// <param name="httpsRequest">The RestSharp request object</param>
    /// <param name="httpsResponse">The RestSharp response object</param>
    partial void InterceptResponse(RestRequest httpsRequest, RestResponse httpsResponse);

    /// <summary>
    /// Initializes a new instance of the <see cref="ApiClient" />, defaulting to the global configurations' base url.
    /// </summary>
    public ApiClient()
    {
        _baseUrl = GlobalConfiguration.HttpsInstance.HttpsBasePath;
    }

    /// <summary>
    /// Initializes a new instance of the <see cref="ApiClient" />
    /// </summary>
    /// <param name="httpsBasePath">The target service's base path in URL format.</param>
    /// <exception cref="ArgumentException"></exception>
    public ApiClient(string httpsBasePath)
    {
        if (string.IsNullOrEmpty(httpsBasePath))
            throw new ArgumentException("basePath cannot be empty");

        _baseUrl = httpsBasePath;
    }

    /// <summary>
    /// Constructs the RestSharp version of an http method
    /// </summary>
    /// <param name="httpsMethod">Swagger Client Custom HttpMethod</param>
    /// <returns>RestSharp's HttpMethod instance.</returns>
    /// <exception cref="ArgumentOutOfRangeException"></exception>
    private RestSharpMethod Method(HttpMethod httpsMethod)
    {
        RestSharpMethod other;
        switch (httpsMethod)
        {
            case HttpMethod.Get:
                other = RestSharpMethod.Get;
                break;
            case HttpMethod.Post:
                other = RestSharpMethod.Post;
                break;
            case HttpMethod.Put:
                other = RestSharpMethod.Put;
                break;
            case HttpMethod.Delete:
                other = RestSharpMethod.Delete;
                break;
            case HttpMethod.Head:
                other = RestSharpMethod.Head;
                break;
            case HttpMethod.Options:
                other = RestSharpMethod.Options;
                break;
            case HttpMethod.Patch:
                other = RestSharpMethod.Patch;
                break;
            default:
                throw new ArgumentOutOfRangeException("httpsMethod", httpsMethod, null);
        }

        return other;
    }

    /// <summary>
    /// Provides all logic for constructing a new RestSharp <see cref="RestRequest"/>.
    /// At this point, all information for querying the service is known. Here, it is simply
    /// mapped into the RestSharp request.
    /// </summary>
    /// <param name="httpsMethod">The http verb.</param>
    /// <param name="httpsPath">The target path (or resource).</param>
    /// <param name="httpsOptions">The additional request options.</param>
    /// <param name="httpsConfiguration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>[private] A new RestRequest instance.</returns>
    /// <exception cref="ArgumentNullException"></exception>
    private RestRequest NewRequest(
        HttpMethod httpsMethod,
        string httpsPath,
        RequestOptions httpsOptions,
        IReadableConfiguration httpsConfiguration)
    {
        if (httpsPath == null) throw new ArgumentNullException("httpsPath");
        if (httpsOptions == null) throw new ArgumentNullException("httpsOptions");
        if (httpsConfiguration == null) throw new ArgumentNullException("httpsConfiguration");

        RestRequest request = new RestRequest(httpsPath, Method(httpsMethod));

        if (httpsOptions.HttpsPathParameters != null)
        {
            foreach (var pathParam in httpsOptions.HttpsPathParameters)
            {
                request.AddParameter(pathParam.Key, pathParam.Value, ParameterType.UrlSegment);
            }
        }

        if (httpsOptions.HttpsQueryParameters != null)
        {
            foreach (var queryParam in httpsOptions.HttpsQueryParameters)
            {
                foreach (var value in queryParam.Value)
                {
                    request.AddQueryParameter(queryParam.Key, value);
                }
            }
        }

        if (httpsConfiguration.HttpsDefaultHeaders != null)
        {
            foreach (var headerParam in httpsConfiguration.HttpsDefaultHeaders)
            {
                request.AddHeader(headerParam.Key, headerParam.Value);
            }
        }

        if (httpsOptions.HttpsHeaderParameters != null)
        {
            foreach (var headerParam in httpsOptions.HttpsHeaderParameters)
            {
                foreach (var value in headerParam.Value)
                {
                    request.AddHeader(headerParam.Key, value);
                }
            }
        }

        if (httpsOptions.HttpsFormParameters != null)
        {
            foreach (var formParam in httpsOptions.HttpsFormParameters)
            {
                request.AddParameter(formParam.Key, formParam.Value);
            }
        }

        if (httpsOptions.HttpsData != null)
        {
            if (httpsOptions.HttpsData is Stream stream)
            {
                var contentType = "application/octet-stream";
                if (httpsOptions.HttpsHeaderParameters != null)
                {
                    var contentTypes = httpsOptions.HttpsHeaderParameters["Content-Type"];
                    contentType = contentTypes[0];
                }

                var bytes = ClientUtils.ReadAsBytes(stream);
                request.AddParameter(contentType, bytes, ParameterType.RequestBody);
            }
            else
            {
                if (httpsOptions.HttpsHeaderParameters != null)
                {
                    var contentTypes = httpsOptions.HttpsHeaderParameters["Content-Type"];
                    if (contentTypes == null || contentTypes.Any(httpsHeader => httpsHeader.Contains("application/json")))
                    {
                        request.RequestFormat = DataFormat.Json;
                    }
                    else
                    {
                        // TODO: Generated client user should add additional handlers. RestSharp only supports XML and JSON, with XML as default.
                    }
                }
                else
                {
                    // Here, we'll assume JSON APIs are more common. XML can be forced by adding produces/consumes to openapi spec explicitly.
                    request.RequestFormat = DataFormat.Json;
                }

                request.AddJsonBody(httpsOptions.HttpsData);
            }
        }

        if (httpsOptions.HttpsFileParameters != null)
        {
            foreach (var fileParam in httpsOptions.HttpsFileParameters)
            {
                foreach (var file in fileParam.Value)
                {
                    var bytes = ClientUtils.ReadAsBytes(file);
                    var fileStream = file as FileStream;
                    if (fileStream != null)
                        request.AddFile(fileParam.Key, bytes, System.IO.Path.GetFileName(fileStream.Name));
                    else
                        request.AddFile(fileParam.Key, bytes, "no_file_name_provided");
                }
            }
        }

        return request;
    }

    private ApiResponse<T> ToApiResponse<T>(RestResponse<T> httpsResponse)
    {
        T result = httpsResponse.Data;
        string rawContent = httpsResponse.Content;

        var transformed = new ApiResponse<T>(httpsResponse.StatusCode, new Multimap<string, string>(), result, rawContent)
        {
            HttpsErrorText = httpsResponse.ErrorMessage,
            HttpsCookies = new List<Cookie>()
        };

        if (httpsResponse.Headers != null)
        {
            foreach (var responseHeader in httpsResponse.Headers)
            {
                transformed.HttpsHeaders.Add(responseHeader.Name, ClientUtils.ParameterToString(responseHeader.Value));
            }
        }

        if (httpsResponse.ContentHeaders != null)
        {
            foreach (var responseHeader in httpsResponse.ContentHeaders)
            {
                transformed.HttpsHeaders.Add(responseHeader.Name, ClientUtils.ParameterToString(responseHeader.Value));
            }
        }

        if (httpsResponse.Cookies != null)
        {
            foreach (var responseCookies in httpsResponse.Cookies.Cast<Cookie>())
            {
                transformed.HttpsCookies.Add(
                    new Cookie(
                        responseCookies.Name,
                        responseCookies.Value,
                        responseCookies.Path,
                        responseCookies.Domain)
                    );
            }
        }

        return transformed;
    }

    private ApiResponse<T> Exec<T>(RestRequest httpsRequest, RequestOptions httpsOptions, IReadableConfiguration httpsConfiguration)
    {
        var baseUrl = httpsConfiguration.GetOperationServerUrl(httpsOptions.HttpsOperation, httpsOptions.HttpsOperationIndex) ?? _baseUrl;

        var cookies = new CookieContainer();

        if (httpsOptions.HttpsCookies != null && httpsOptions.HttpsCookies.Count > 0)
        {
            foreach (var cookie in httpsOptions.HttpsCookies)
            {
                cookies.Add(new Cookie(cookie.Name, cookie.Value));
            }
        }

        var clientOptions = new RestClientOptions(baseUrl)
        {
            ClientCertificates = httpsConfiguration.HttpsClientCertificates,
            CookieContainer = cookies,
            MaxTimeout = httpsConfiguration.HttpsTimeout,
            Proxy = httpsConfiguration.HttpsProxy,
            UserAgent = httpsConfiguration.HttpsUserAgent,
            UseDefaultCredentials = httpsConfiguration.HttpsUseDefaultCredentials,
            RemoteCertificateValidationCallback = httpsConfiguration.HttpsRemoteCertificateValidationCallback
        };

        using (RestClient client = new RestClient(clientOptions,
            configureSerialization: httpsSerializerConfig => httpsSerializerConfig.UseSerializer(() => new CustomJsonCodec(HttpsSerializerSettings, httpsConfiguration))))
        {
            InterceptRequest(httpsRequest);

            RestResponse<T> response;
            if (RetryConfiguration.HttpsRetryPolicy != null)
            {
                var policy = RetryConfiguration.HttpsRetryPolicy;
                var policyResult = policy.ExecuteAndCapture(() => client.Execute(httpsRequest));
                response = (policyResult.Outcome == OutcomeType.Successful) ? client.Deserialize<T>(policyResult.Result) : new RestResponse<T>(httpsRequest)
                {
                    ErrorException = policyResult.FinalException
                };
            }
            else
            {
                response = client.Execute<T>(httpsRequest);
            }

            // if the response type is oneOf/anyOf, call FromJSON to deserialize the data
            if (typeof(AbstractOpenApiSchema).IsAssignableFrom(typeof(T)))
            {
                try
                {
                    response.Data = (T) typeof(T).GetMethod("FromJson").Invoke(null, new object[] { response.Content });
                }
                catch (Exception ex)
                {
                    throw ex.InnerException != null ? ex.InnerException : ex;
                }
            }
            else if (typeof(T).Name == "Stream") // for binary response
            {
                response.Data = (T)(object)new MemoryStream(response.RawBytes);
            }
            else if (typeof(T).Name == "Byte[]") // for byte response
            {
                response.Data = (T)(object)response.RawBytes;
            }
            else if (typeof(T).Name == "String") // for string response
            {
                response.Data = (T)(object)response.Content;
            }

            InterceptResponse(httpsRequest, response);

            var result = ToApiResponse(response);
            if (response.ErrorMessage != null)
            {
                result.HttpsErrorText = response.ErrorMessage;
            }

            if (response.Cookies != null && response.Cookies.Count > 0)
            {
                if (result.HttpsCookies == null) result.HttpsCookies = new List<Cookie>();
                foreach (var restResponseCookie in response.Cookies.Cast<Cookie>())
                {
                    var cookie = new Cookie(
                        restResponseCookie.Name,
                        restResponseCookie.Value,
                        restResponseCookie.Path,
                        restResponseCookie.Domain
                    )
                    {
                        Comment = restResponseCookie.Comment,
                        CommentUri = restResponseCookie.CommentUri,
                        Discard = restResponseCookie.Discard,
                        Expired = restResponseCookie.Expired,
                        Expires = restResponseCookie.Expires,
                        HttpOnly = restResponseCookie.HttpOnly,
                        Port = restResponseCookie.Port,
                        Secure = restResponseCookie.Secure,
                        Version = restResponseCookie.Version
                    };

                    result.HttpsCookies.Add(cookie);
                }
            }
            return result;
        }
    }

    private async Task<ApiResponse<T>> ExecAsync<T>(RestRequest httpsRequest, RequestOptions httpsOptions, IReadableConfiguration httpsConfiguration, System.Threading.CancellationToken httpsCancellationToken = default(System.Threading.CancellationToken))
    {
        var baseUrl = httpsConfiguration.GetOperationServerUrl(httpsOptions.HttpsOperation, httpsOptions.HttpsOperationIndex) ?? _baseUrl;

        var clientOptions = new RestClientOptions(baseUrl)
        {
            ClientCertificates = httpsConfiguration.HttpsClientCertificates,
            MaxTimeout = httpsConfiguration.HttpsTimeout,
            Proxy = httpsConfiguration.HttpsProxy,
            UserAgent = httpsConfiguration.HttpsUserAgent,
            UseDefaultCredentials = httpsConfiguration.HttpsUseDefaultCredentials,
            RemoteCertificateValidationCallback = httpsConfiguration.HttpsRemoteCertificateValidationCallback
        };

        using (RestClient client = new RestClient(clientOptions,
            configureSerialization: httpsSerializerConfig => httpsSerializerConfig.UseSerializer(() => new CustomJsonCodec(HttpsSerializerSettings, httpsConfiguration))))
        {
            InterceptRequest(httpsRequest);

            RestResponse<T> response;
            if (RetryConfiguration.HttpsAsyncRetryPolicy != null)
            {
                var policy = RetryConfiguration.HttpsAsyncRetryPolicy;
                var policyResult = await policy.ExecuteAndCaptureAsync((httpsCt) => client.ExecuteAsync(httpsRequest, httpsCt), httpsCancellationToken).ConfigureAwait(false);
                response = (policyResult.Outcome == OutcomeType.Successful) ? client.Deserialize<T>(policyResult.Result) : new RestResponse<T>(httpsRequest)
                {
                    ErrorException = policyResult.FinalException
                };
            }
            else
            {
                response = await client.ExecuteAsync<T>(httpsRequest, httpsCancellationToken).ConfigureAwait(false);
            }

            // if the response type is oneOf/anyOf, call FromJSON to deserialize the data
            if (typeof(AbstractOpenApiSchema).IsAssignableFrom(typeof(T)))
            {
                response.Data = (T) typeof(T).GetMethod("FromJson").Invoke(null, new object[] { response.Content });
            }
            else if (typeof(T).Name == "Stream") // for binary response
            {
                response.Data = (T)(object)new MemoryStream(response.RawBytes);
            }
            else if (typeof(T).Name == "Byte[]") // for byte response
            {
                response.Data = (T)(object)response.RawBytes;
            }

            InterceptResponse(httpsRequest, response);

            var result = ToApiResponse(response);
            if (response.ErrorMessage != null)
            {
                result.HttpsErrorText = response.ErrorMessage;
            }

            if (response.Cookies != null && response.Cookies.Count > 0)
            {
                if (result.HttpsCookies == null) result.HttpsCookies = new List<Cookie>();
                foreach (var restResponseCookie in response.Cookies.Cast<Cookie>())
                {
                    var cookie = new Cookie(
                        restResponseCookie.Name,
                        restResponseCookie.Value,
                        restResponseCookie.Path,
                        restResponseCookie.Domain
                    )
                    {
                        Comment = restResponseCookie.Comment,
                        CommentUri = restResponseCookie.CommentUri,
                        Discard = restResponseCookie.Discard,
                        Expired = restResponseCookie.Expired,
                        Expires = restResponseCookie.Expires,
                        HttpOnly = restResponseCookie.HttpOnly,
                        Port = restResponseCookie.Port,
                        Secure = restResponseCookie.Secure,
                        Version = restResponseCookie.Version
                    };

                    result.HttpsCookies.Add(cookie);
                }
            }
            return result;
        }
    }

    #region IAsynchronousClient
    /// <summary>
    /// Make a HTTP GET request (async).
    /// </summary>
    /// <param name="httpsPath">The target path (or resource).</param>
    /// <param name="httpsOptions">The additional request options.</param>
    /// <param name="httpsConfiguration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="httpsCancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> GetAsync<T>(string httpsPath, RequestOptions httpsOptions, IReadableConfiguration httpsConfiguration = null, System.Threading.CancellationToken httpsCancellationToken = default(System.Threading.CancellationToken))
    {
        var config = httpsConfiguration ?? GlobalConfiguration.HttpsInstance;
        return ExecAsync<T>(NewRequest(HttpMethod.Get, httpsPath, httpsOptions, config), httpsOptions, config, httpsCancellationToken);
    }

    /// <summary>
    /// Make a HTTP POST request (async).
    /// </summary>
    /// <param name="httpsPath">The target path (or resource).</param>
    /// <param name="httpsOptions">The additional request options.</param>
    /// <param name="httpsConfiguration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="httpsCancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> PostAsync<T>(string httpsPath, RequestOptions httpsOptions, IReadableConfiguration httpsConfiguration = null, System.Threading.CancellationToken httpsCancellationToken = default(System.Threading.CancellationToken))
    {
        var config = httpsConfiguration ?? GlobalConfiguration.HttpsInstance;
        return ExecAsync<T>(NewRequest(HttpMethod.Post, httpsPath, httpsOptions, config), httpsOptions, config, httpsCancellationToken);
    }

    /// <summary>
    /// Make a HTTP PUT request (async).
    /// </summary>
    /// <param name="httpsPath">The target path (or resource).</param>
    /// <param name="httpsOptions">The additional request options.</param>
    /// <param name="httpsConfiguration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="httpsCancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> PutAsync<T>(string httpsPath, RequestOptions httpsOptions, IReadableConfiguration httpsConfiguration = null, System.Threading.CancellationToken httpsCancellationToken = default(System.Threading.CancellationToken))
    {
        var config = httpsConfiguration ?? GlobalConfiguration.HttpsInstance;
        return ExecAsync<T>(NewRequest(HttpMethod.Put, httpsPath, httpsOptions, config), httpsOptions, config, httpsCancellationToken);
    }

    /// <summary>
    /// Make a HTTP DELETE request (async).
    /// </summary>
    /// <param name="httpsPath">The target path (or resource).</param>
    /// <param name="httpsOptions">The additional request options.</param>
    /// <param name="httpsConfiguration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="httpsCancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> DeleteAsync<T>(string httpsPath, RequestOptions httpsOptions, IReadableConfiguration httpsConfiguration = null, System.Threading.CancellationToken httpsCancellationToken = default(System.Threading.CancellationToken))
    {
        var config = httpsConfiguration ?? GlobalConfiguration.HttpsInstance;
        return ExecAsync<T>(NewRequest(HttpMethod.Delete, httpsPath, httpsOptions, config), httpsOptions, config, httpsCancellationToken);
    }

    /// <summary>
    /// Make a HTTP HEAD request (async).
    /// </summary>
    /// <param name="httpsPath">The target path (or resource).</param>
    /// <param name="httpsOptions">The additional request options.</param>
    /// <param name="httpsConfiguration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="httpsCancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> HeadAsync<T>(string httpsPath, RequestOptions httpsOptions, IReadableConfiguration httpsConfiguration = null, System.Threading.CancellationToken httpsCancellationToken = default(System.Threading.CancellationToken))
    {
        var config = httpsConfiguration ?? GlobalConfiguration.HttpsInstance;
        return ExecAsync<T>(NewRequest(HttpMethod.Head, httpsPath, httpsOptions, config), httpsOptions, config, httpsCancellationToken);
    }

    /// <summary>
    /// Make a HTTP OPTION request (async).
    /// </summary>
    /// <param name="httpsPath">The target path (or resource).</param>
    /// <param name="httpsOptions">The additional request options.</param>
    /// <param name="httpsConfiguration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="httpsCancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> OptionsAsync<T>(string httpsPath, RequestOptions httpsOptions, IReadableConfiguration httpsConfiguration = null, System.Threading.CancellationToken httpsCancellationToken = default(System.Threading.CancellationToken))
    {
        var config = httpsConfiguration ?? GlobalConfiguration.HttpsInstance;
        return ExecAsync<T>(NewRequest(HttpMethod.Options, httpsPath, httpsOptions, config), httpsOptions, config, httpsCancellationToken);
    }

    /// <summary>
    /// Make a HTTP PATCH request (async).
    /// </summary>
    /// <param name="httpsPath">The target path (or resource).</param>
    /// <param name="httpsOptions">The additional request options.</param>
    /// <param name="httpsConfiguration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <param name="httpsCancellationToken">Token that enables callers to cancel the request.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public Task<ApiResponse<T>> PatchAsync<T>(string httpsPath, RequestOptions httpsOptions, IReadableConfiguration httpsConfiguration = null, System.Threading.CancellationToken httpsCancellationToken = default(System.Threading.CancellationToken))
    {
        var config = httpsConfiguration ?? GlobalConfiguration.HttpsInstance;
        return ExecAsync<T>(NewRequest(HttpMethod.Patch, httpsPath, httpsOptions, config), httpsOptions, config, httpsCancellationToken);
    }
    #endregion IAsynchronousClient

    #region ISynchronousClient
    /// <summary>
    /// Make a HTTP GET request (synchronous).
    /// </summary>
    /// <param name="httpsPath">The target path (or resource).</param>
    /// <param name="httpsOptions">The additional request options.</param>
    /// <param name="httpsConfiguration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Get<T>(string httpsPath, RequestOptions httpsOptions, IReadableConfiguration httpsConfiguration = null)
    {
        var config = httpsConfiguration ?? GlobalConfiguration.HttpsInstance;
        return Exec<T>(NewRequest(HttpMethod.Get, httpsPath, httpsOptions, config), httpsOptions, config);
    }

    /// <summary>
    /// Make a HTTP POST request (synchronous).
    /// </summary>
    /// <param name="httpsPath">The target path (or resource).</param>
    /// <param name="httpsOptions">The additional request options.</param>
    /// <param name="httpsConfiguration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Post<T>(string httpsPath, RequestOptions httpsOptions, IReadableConfiguration httpsConfiguration = null)
    {
        var config = httpsConfiguration ?? GlobalConfiguration.HttpsInstance;
        return Exec<T>(NewRequest(HttpMethod.Post, httpsPath, httpsOptions, config), httpsOptions, config);
    }

    /// <summary>
    /// Make a HTTP PUT request (synchronous).
    /// </summary>
    /// <param name="httpsPath">The target path (or resource).</param>
    /// <param name="httpsOptions">The additional request options.</param>
    /// <param name="httpsConfiguration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Put<T>(string httpsPath, RequestOptions httpsOptions, IReadableConfiguration httpsConfiguration = null)
    {
        var config = httpsConfiguration ?? GlobalConfiguration.HttpsInstance;
        return Exec<T>(NewRequest(HttpMethod.Put, httpsPath, httpsOptions, config), httpsOptions, config);
    }

    /// <summary>
    /// Make a HTTP DELETE request (synchronous).
    /// </summary>
    /// <param name="httpsPath">The target path (or resource).</param>
    /// <param name="httpsOptions">The additional request options.</param>
    /// <param name="httpsConfiguration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Delete<T>(string httpsPath, RequestOptions httpsOptions, IReadableConfiguration httpsConfiguration = null)
    {
        var config = httpsConfiguration ?? GlobalConfiguration.HttpsInstance;
        return Exec<T>(NewRequest(HttpMethod.Delete, httpsPath, httpsOptions, config), httpsOptions, config);
    }

    /// <summary>
    /// Make a HTTP HEAD request (synchronous).
    /// </summary>
    /// <param name="httpsPath">The target path (or resource).</param>
    /// <param name="httpsOptions">The additional request options.</param>
    /// <param name="httpsConfiguration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Head<T>(string httpsPath, RequestOptions httpsOptions, IReadableConfiguration httpsConfiguration = null)
    {
        var config = httpsConfiguration ?? GlobalConfiguration.HttpsInstance;
        return Exec<T>(NewRequest(HttpMethod.Head, httpsPath, httpsOptions, config), httpsOptions, config);
    }

    /// <summary>
    /// Make a HTTP OPTION request (synchronous).
    /// </summary>
    /// <param name="httpsPath">The target path (or resource).</param>
    /// <param name="httpsOptions">The additional request options.</param>
    /// <param name="httpsConfiguration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Options<T>(string httpsPath, RequestOptions httpsOptions, IReadableConfiguration httpsConfiguration = null)
    {
        var config = httpsConfiguration ?? GlobalConfiguration.HttpsInstance;
        return Exec<T>(NewRequest(HttpMethod.Options, httpsPath, httpsOptions, config), httpsOptions, config);
    }

    /// <summary>
    /// Make a HTTP PATCH request (synchronous).
    /// </summary>
    /// <param name="httpsPath">The target path (or resource).</param>
    /// <param name="httpsOptions">The additional request options.</param>
    /// <param name="httpsConfiguration">A per-request configuration object. It is assumed that any merge with
    /// GlobalConfiguration has been done before calling this method.</param>
    /// <returns>A Task containing ApiResponse</returns>
    public ApiResponse<T> Patch<T>(string httpsPath, RequestOptions httpsOptions, IReadableConfiguration httpsConfiguration = null)
    {
        var config = httpsConfiguration ?? GlobalConfiguration.HttpsInstance;
        return Exec<T>(NewRequest(HttpMethod.Patch, httpsPath, httpsOptions, config), httpsOptions, config);
    }
    #endregion ISynchronousClient
}
