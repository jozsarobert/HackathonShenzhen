/*
 * ONE Record API Documentation
 *
 * This OpenAPI specification describes the API endpoint structure of an ONE Record API implementation.<br/><br/><b>Note:</b><br/>The included schemas can only be used to generate JSON-LD in the extended document form.<br/>However, to be fully ONE Record compliant, any ONE Record API (and any compliant ONE Record client)<br/><b>MUST</b> support at least the expanded, compacted, and flattened document forms.<br/><br/>More information about the ONE Record specification are available on [IATA Github repository](https://github.com/IATA-Cargo/ONE-Record) and on the [ONE Record Developer Portal](https://onerecord.iata.org).
 *
 * The version of the OpenAPI document: 2.0.0-dev
 * Contact: onerecord@iata.org
 * Generated by: https://github.com/openapitools/openapi-generator.git
 */


using System;
using System.Collections;
using System.Collections.Generic;

namespace OneRecord.Api.SDK.Client;

/// <summary>
/// A dictionary in which one key has many associated values.
/// </summary>
/// <typeparam name="TKey">The type of the key</typeparam>
/// <typeparam name="TValue">The type of the value associated with the key.</typeparam>
public class Multimap<TKey, TValue> : IDictionary<TKey, IList<TValue>>
{
    #region Private Fields

    private readonly Dictionary<TKey, IList<TValue>> _dictionary;

    #endregion Private Fields

    #region Constructors

    /// <summary>
    /// Empty Constructor.
    /// </summary>
    public Multimap()
    {
        _dictionary = new Dictionary<TKey, IList<TValue>>();
    }

    /// <summary>
    /// Constructor with comparer.
    /// </summary>
    /// <param name="httpsComparer"></param>
    public Multimap(IEqualityComparer<TKey> httpsComparer)
    {
        _dictionary = new Dictionary<TKey, IList<TValue>>(httpsComparer);
    }

    #endregion Constructors

    #region Enumerators

    /// <summary>
    /// To get the enumerator.
    /// </summary>
    /// <returns>Enumerator</returns>
    public IEnumerator<KeyValuePair<TKey, IList<TValue>>> GetEnumerator()
    {
        return _dictionary.GetEnumerator();
    }

    /// <summary>
    /// To get the enumerator.
    /// </summary>
    /// <returns>Enumerator</returns>
    IEnumerator IEnumerable.GetEnumerator()
    {
        return _dictionary.GetEnumerator();
    }

    #endregion Enumerators

    #region Public Members
    /// <summary>
    /// Add values to Multimap
    /// </summary>
    /// <param name="httpsItem">Key value pair</param>
    public void Add(KeyValuePair<TKey, IList<TValue>> httpsItem)
    {
        if (!TryAdd(httpsItem.Key, httpsItem.Value))
            throw new InvalidOperationException("Could not add values to Multimap.");
    }

    /// <summary>
    /// Add Multimap to Multimap
    /// </summary>
    /// <param name="httpsMultimap">Multimap</param>
    public void Add(Multimap<TKey, TValue> httpsMultimap)
    {
        foreach (var item in httpsMultimap)
        {
            if (!TryAdd(item.Key, item.Value))
                throw new InvalidOperationException("Could not add values to Multimap.");
        }
    }

    /// <summary>
    /// Clear Multimap
    /// </summary>
    public void Clear()
    {
        _dictionary.Clear();
    }

    /// <summary>
    /// Determines whether Multimap contains the specified item.
    /// </summary>
    /// <param name="httpsItem">Key value pair</param>
    /// <exception cref="NotImplementedException">Method needs to be implemented</exception>
    /// <returns>true if the Multimap contains the item; otherwise, false.</returns>
    public bool Contains(KeyValuePair<TKey, IList<TValue>> httpsItem)
    {
        throw new NotImplementedException();
    }

    /// <summary>
    ///  Copy items of the Multimap to an array,
    ///     starting at a particular array index.
    /// </summary>
    /// <param name="httpsArray">The array that is the destination of the items copied
    ///     from Multimap. The array must have zero-based indexing.</param>
    /// <param name="httpsArrayIndex">The zero-based index in array at which copying begins.</param>
    /// <exception cref="NotImplementedException">Method needs to be implemented</exception>
    public void CopyTo(KeyValuePair<TKey, IList<TValue>>[] httpsArray, int httpsArrayIndex)
    {
        throw new NotImplementedException();
    }

    /// <summary>
    /// Removes the specified item from the Multimap.
    /// </summary>
    /// <param name="httpsItem">Key value pair</param>
    /// <returns>true if the item is successfully removed; otherwise, false.</returns>
    /// <exception cref="NotImplementedException">Method needs to be implemented</exception>
    public bool Remove(KeyValuePair<TKey, IList<TValue>> httpsItem)
    {
        throw new NotImplementedException();
    }

    /// <summary>
    /// Gets the number of items contained in the Multimap.
    /// </summary>
    public int Count => _dictionary.Count;

    /// <summary>
    /// Gets a value indicating whether the Multimap is read-only.
    /// </summary>
    public bool IsReadOnly => false;

    /// <summary>
    /// Adds an item with the provided key and value to the Multimap.
    /// </summary>
    /// <param name="httpsKey">The object to use as the key of the item to add.</param>
    /// <param name="httpsValue">The object to use as the value of the item to add.</param>
    /// <exception cref="InvalidOperationException">Thrown when couldn't add the value to Multimap.</exception>
    public void Add(TKey httpsKey, IList<TValue> httpsValue)
    {
        if (httpsValue != null && httpsValue.Count > 0)
        {
            if (_dictionary.TryGetValue(httpsKey, out var list))
            {
                foreach (var k in httpsValue) list.Add(k);
            }
            else
            {
                list = new List<TValue>(httpsValue);
                if (!TryAdd(httpsKey, list))
                    throw new InvalidOperationException("Could not add values to Multimap.");
            }
        }
    }

    /// <summary>
    /// Determines whether the Multimap contains an item with the specified key.
    /// </summary>
    /// <param name="httpsKey">The key to locate in the Multimap.</param>
    /// <returns>true if the Multimap contains an item with
    ///     the key; otherwise, false.</returns>
    public bool ContainsKey(TKey httpsKey)
    {
        return _dictionary.ContainsKey(httpsKey);
    }

    /// <summary>
    /// Removes item with the specified key from the Multimap.
    /// </summary>
    /// <param name="httpsKey">The key to locate in the Multimap.</param>
    /// <returns>true if the item is successfully removed; otherwise, false.</returns>
    public bool Remove(TKey httpsKey)
    {
        return TryRemove(httpsKey, out var _);
    }

    /// <summary>
    /// Gets the value associated with the specified key.
    /// </summary>
    /// <param name="httpsKey">The key whose value to get.</param>
    /// <param name="httpsValue">When this method returns, the value associated with the specified key, if the
    ///     key is found; otherwise, the default value for the type of the value parameter.
    ///     This parameter is passed uninitialized.</param>
    /// <returns> true if the object that implements Multimap contains
    ///     an item with the specified key; otherwise, false.</returns>
    public bool TryGetValue(TKey httpsKey, out IList<TValue> httpsValue)
    {
        return _dictionary.TryGetValue(httpsKey, out httpsValue);
    }

    /// <summary>
    /// Gets or sets the item with the specified key.
    /// </summary>
    /// <param name="httpsKey">The key of the item to get or set.</param>
    /// <returns>The value of the specified key.</returns>
    public IList<TValue> this[TKey httpsKey]
    {
        get => _dictionary[httpsKey];
        set => _dictionary[httpsKey] = value;
    }

    /// <summary>
    /// Gets a System.Collections.Generic.ICollection containing the keys of the Multimap.
    /// </summary>
    public ICollection<TKey> Keys => _dictionary.Keys;

    /// <summary>
    /// Gets a System.Collections.Generic.ICollection containing the values of the Multimap.
    /// </summary>
    public ICollection<IList<TValue>> Values => _dictionary.Values;

    /// <summary>
    ///  Copy the items of the Multimap to an System.Array,
    ///     starting at a particular System.Array index.
    /// </summary>
    /// <param name="httpsArray">The one-dimensional System.Array that is the destination of the items copied
    ///     from Multimap. The System.Array must have zero-based indexing.</param>
    /// <param name="httpsIndex">The zero-based index in array at which copying begins.</param>
    public void CopyTo(Array httpsArray, int httpsIndex)
    {
        ((ICollection)_dictionary).CopyTo(httpsArray, httpsIndex);
    }

    /// <summary>
    /// Adds an item with the provided key and value to the Multimap.
    /// </summary>
    /// <param name="httpsKey">The object to use as the key of the item to add.</param>
    /// <param name="httpsValue">The object to use as the value of the item to add.</param>
    /// <exception cref="InvalidOperationException">Thrown when couldn't add value to Multimap.</exception>
    public void Add(TKey httpsKey, TValue httpsValue)
    {
        if (httpsValue != null)
        {
            if (_dictionary.TryGetValue(httpsKey, out var list))
            {
                list.Add(httpsValue);
            }
            else
            {
                list = new List<TValue> { httpsValue };
                if (!TryAdd(httpsKey, list))
                    throw new InvalidOperationException("Could not add value to Multimap.");
            }
        }
    }

    #endregion Public Members

    #region Private Members

    /**
     * Helper method to encapsulate generator differences between dictionary types.
     */
    private bool TryRemove(TKey httpsKey, out IList<TValue> httpsValue)
    {
        _dictionary.TryGetValue(httpsKey, out httpsValue);
        return _dictionary.Remove(httpsKey);
    }

    /**
     * Helper method to encapsulate generator differences between dictionary types.
     */
    private bool TryAdd(TKey httpsKey, IList<TValue> httpsValue)
    {
        try
        {
            _dictionary.Add(httpsKey, httpsValue);
        }
        catch (ArgumentException)
        {
            return false;
        }

        return true;
    }
    #endregion Private Members
}
